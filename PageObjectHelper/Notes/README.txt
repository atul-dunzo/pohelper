PAGE OBJECT HELPER
------------------

Overview
--------
The PageObjectHelper is designed to generate the boilerplate parts of a Selenium-WebDriver page object, reducing the time
spent writing page objects and, in particular, WebElement locators.  It currently generates compileable java code but is
designed to support additional languages.

This project is a work-in-progress.  It is an attempt at a tool that generates WebDriver page object code, eliminating
the time consuming work of
- Retrieving from the applications DOM unique IDs, name attributes, and classnames.
- Generating element locators, particularly CSS Selectors where IDs or name attributes don't exist.
  (xpath not yet supported but could be)
- Generating boilerplate getters and setters for the WebElements identified by the tool.
- Writing a compile-ready page object class which can be easily extended for additional behavior, and immediately used
by a test running against the application to be tested.


Getting Started
---------------

To get started simply import the project into your favorite IDE using the Maven Import feature.


Two Modules
-----------
There are two modules in the project.
1)  PageObjectHelper is the page object generation tool itself.
2)  PageObjectTester is an example test project that can be used to run page objects generated by the tool.


Running the Project
-------------------
This project can be run from an IDE (I use IntelliJ) or from the command-line.

To run from the IDE create a Run Configuration and set
- The working directory to RunFolder
- The command-line parameters for the URL for the webpage you will be generating code for and for the destination folder
  where the generated code will be written.

For example, in IntelliJ
- Go to Edit Configurations and create a Run Configuration, or edit one if one already exists.
- Set the Working Directory field to the RunFolder.  i.e. for my project <Project Root>/RunFolder
- Set the Program Arguments field to
   -generate code -url http://www.cnn.com -dest <Project Root>/PageObjectTester/src/main/java/com/pagerunner/pageobjects
(note: in this case the '-' is not a 'bullet' but actually indicates a command-line argument)

The destination folder passed to -dest can be any folder where you want to put the generated code.  However if you
want to run it using a Selenium test you will want to send this to a Selenium Test Project.  The PageObjectTester
module under this project is a pre-configured test module serving as an example.  You can send the generated code
to the com.pagerunner.pageobjects package under this module and then write your own tests in the corresponding 'tests'
package to run the generated page object.

To run from the command-line you will need to
- Build the project
- Create and build a build-artifact to create a jar file.
- Copy the jar file from your project's build-artifact output folder to a folder of your choosing.
- Copy the resources sub-folder under the project's RunFolder, and all it's contents, to a sub-folder called 'resources'
  under the folder where you copied the jar.
- Run the jar as you would any other jar, but pass in the two command line params -url and -dest as described above.

Command-line Params
-------------------
- I typically run with the -url and -dest options.  I set these in the IDE's run params input box.  For example

    -url http://<my remote page> -dest <Path to My Projects Folder>/PageObjectRunner/src/main/java/com/selgentests/pageobjects

This defaults to generating the page object code although there are other options, see below.

  For example: Here's one I commonly ran when testing the app:

  -url http://www.cnn.com -dest /Users/pgrandje/IdeaProjects/POHelper/PageObjectRunner/src/main/java/com/selgentests/pageobjects

- Currently I'm not running this from the command-line yet, although if you're comfortable setting up a typical java runtime
environment you should only need to be sure your CLASSPATH is set correctly to run from the command-line.
only from the IDE.

Other options
-generate code | hints | codefromhints
-codeShell or -codeShellTemplate -- for setting the filepath of the code template file.  This is the file that defines
 the other shell, such as the class name, for the page object.
-tagSwitch or tagSwitchTemplate -- specifies the filepath for the tags to be used for code generation and the code template
 snippets for code generation.
-loc or -locator -- specifies the strategy to use for writing WebElement locators.
-defMem or -defaultMemberName -- specifies the string to use by default for WebElement members when no useful string
 from the corresponding HTML tag can be used.
-h or -help -- displays command-line help.


To run from the command-line you will need to manually deploy the jar and configuration files to a folder of your
choosing.  This project does not yet have a deploy target in its Maven configuration.


The RunFolder
----------------------------
The RunFolder contains the code template files necessary for code generation.  They are in the RunFolder/resources
sub-folder.  If running from an IDE the Working Directory should be set to this RunFolder in the IDE's run
configuration settings.  The logs will also be written to the RunFolder.


Coe Template Files - Language Support and Generation Configuration
------------------------------------------------------------------
The code generation is based on a simple text-based code template file.  This template file could be re-written to
support the other languages supported by Selenium, i.e. Ruby, Python, or C#.

The current java-template has records for specific html tags where code would be generated.  For example, the following
record from the java-template defines code generation for anchor tags.

<*** New Tag ***>
<a>
<-- Code Block Begin -->
<-- Member Code Block -->
   @FindBy(<locator>)
   private WebElement <symbol>_a;
<-- Method Code Block -->
   public String get<symbol>LinkText() {
      return <symbol>_a.getText();
   }

   public void click<symbol>() {
      <symbol>_a.click();
   }
<-- Code Block End -->

The indicators '<locator>' and '<symbol>' are placeholders that get filled in by the Page Object Helper based on
information retrieved from the appliction's DOM.  Additional records can be created to support HTML tags not already
listed in the template.  Also, this file could be re-written to support Ruby, Python, or C#.


Log Files
--------------------
- These are stored in the folder POHelper/RunFolder.  There is extensive logging throughout the app.  All the major
modules will have their own log file.


Assumptions
-----------
Any IDs in the HTML page source are unique within a page.  This is an expectation of any Selenium test suite.

Classnames may optionally be used as locators but if they are used, they must be unique within a page.  However they may be
built into part of a css locator if they are determined by the locator builder to be unique within a subtree of HTML
under a tag with a unique ID.


Limitations and Work to Be Done
-------------------------------
The following items are limitations which are planned enhancements to this project.

- Crawling the site to generate page objects has been worked on but is not yet fully implemented.

- Currently, when CSS Selectors are generated for the WebElement locator, very long css paths are created.  This is
  unnecessary and would lead to brittle tests.  These are generated when no ID is found.  For example,

    @FindBy(css = "body > header > nav > div > div:nth-child(3) > div:nth-child(2) > div > div")
    private WebElement Sign_in4_div;

  There may be situations however where classnames or other tag attributes can be used to shorten these paths.  This is
  an enhancement to be added to the project.

 - Page Objects can be very large and need to be split into smaller page components.
   The page objects generated are not typical of a real Selenium test suite.  Typically a page object would be broken
   into smaller components that match different sub-sections of a page.  This is to enhance reusability and code
   maintenance.  The PageObjectHelper will need a way to indicate when to split the code generation into a
   separate page component class.  This work is planned and will be done through the use of two mechanism currently being
    worked on.
    - Running the generation in 'interactive mode' from an interactive command-line.  This feature will have a 'split'
      command to split the current generation off to a separate page object, and then to re-'join' the current
      generation of the parent or 'containing' page object.
    - Generating the code from a 'hints file' (already implemented) where the user will add a marker to indidate  split
      and re-join operations.

